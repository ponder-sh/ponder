---
title: "Direct SQL"
description: "How to query the Ponder database"
---

import { Callout, FileTree, Steps } from "nextra/components";

# Query the database

This guide explains how to connect to the database (either SQLite or Postgres) and run direct SQL queries.

## SQLite

### Database files

During local development, Ponder uses SQLite database files located in the `.ponder/sqlite` directory.

<FileTree>
  <FileTree.Folder name=".ponder/sqlite" open>
    <FileTree.File name="public.db" />
    <FileTree.File name="ponder_sync.db" />
  </FileTree.Folder>
</FileTree>

- **`public.db`**: Contains a live indexed table for each table in `ponder.schema.ts`. It's safe to read data from this database during local development and testing.
- **`ponder_sync.db`**: Contains raw blockchain data that has been cached locally.

Note: SQLite sometimes creates a `-shm` and `-wal` file alongside database files. Do not modify or delete them.

### Connect with `sqlite3`

To get oriented, connect to the SQLite database using `sqlite3` ([installation guide](https://www.sqlitetutorial.net/download-install-sqlite/)) and run a few test queries. For the queries that follow, assume there is a Ponder app running with this `ponder.schema.ts`.

<details>
  <summary><p>Example `ponder.schema.ts`</p></summary>
  <p />

  ```ts filename="ponder.schema.ts"
  import { createSchema } from "@ponder/core";

  export default createSchema((p) => ({
    Account: p.createTable({
      id: p.hex(),
      balance: p.bigint(),
      isOwner: p.boolean(),
    }),
    TransferEvent: p.createTable({
      id: p.string(),
      amount: p.bigint(),
      timestamp: p.int(),
      fromId: p.hex().references("Account.id"),
      toId: p.hex().references("Account.id"),
    }),
  }));
  ```
</details>

<Steps>

#### File path

Connect to the database by passing a file path to `sqlite3`.

```bash filename="shell"
# From your project root
sqlite3 .ponder/sqlite/public.db

# Or, an absolute path
sqlite3 /workspace/my-app/.ponder/sqlite/public.db
```

Once connected, you'll see a `sqlite>` prompt.

```plaintext filename="shell"
SQLite version 3.37.0 2021-12-09 01:34:53
Enter ".help" for usage hints.
sqlite> 
```

#### Display tables

Use the `.tables` command to list all tables in the database.

```bash filename="sqlite3"
.tables
```

```plaintext filename="sqlite3 (result)"
sqlite> .tables
Account        TransferEvent
```

#### Display schema

Use the `.schema` command to print CREATE TABLE statements for each table.

```bash filename="sqlite3"
.schema
```

```plaintext filename="sqlite3 (result)"
sqlite> .schema
CREATE TABLE IF NOT EXISTS "Account" ("id" blob not null primary key, "balance" varchar(79) not null, "isOwner" integer not null);
CREATE TABLE IF NOT EXISTS "TransferEvent" ("id" text not null primary key, "amount" varchar(79) not null, "timestamp" integer not null, "fromId" blob not null, "toId" blob not null);
```

#### Select rows

First, adjust some settings to make `sqlite3` results easier to read.

```sql filename="sqlite3"
.headers ON
.mode columns
```

Select a few `TransferEvent` rows.

```sql filename="sqlite3"
SELECT * FROM TransferEvent LIMIT 3;
```

```plaintext filename="sqlite3 (result)"
sqlite> SELECT * FROM TransferEvent LIMIT 3;
id                                                                        amount                                                                           timestamp   fromId  toId             
------------------------------------------------------------------------  -------------------------------------------------------------------------------  ----------  ------  -----------------
0x3783f4bba84605ffa296db73fcbdb010caf0542b460035d7bed4129db02fd0e2-0x1a5  0000000000000000000000000000000000000000000000000000000010000000000000000000000  1630539461          ???\???<0???%d?? 
0xd8612316d81529ccc73faf26318594a50cc4dffbbe0553ccf7a14a514f889fff-0xd5   0000000000000000000000000000000000000000000000000000000010000000000000000000000  1630541604          ??ÉhP/w?~?mrrW???R
0x1605392466b635d4eb1552f66832ade6da40a904b00566502b4ba3bdb08ab6a8-0x1a3  0000000000000000000000000000000000000000000000000000000010000000000000000000000  1630541770          ?7g?ʲo&??<}?x
```

Clearly, raw `sqlite3` results are not easy on the eyes. The `balance` column is encoded as `VARCHAR(79){:sql}`, and the `toId` column contains hex values encoded as `BLOB{:sql}`. See the [column types](#column-types) section for more details.

#### Aggregate data

Select all `Account` records that have received more than 10 transfers.

```sql filename="sqlite3"
SELECT *
  FROM Account
  WHERE id IN (
    SELECT toId
      FROM TransferEvent
      GROUP BY toId
      HAVING COUNT(*) > 10
  )
  LIMIT 3;
```

```plaintext filename="sqlite3 (result)"
sqlite> SELECT * FROM Account WHERE id IN ( SELECT toId FROM TransferEvent GROUP BY toId HAVING COUNT(*) > 10 ) LIMIT 3;
id                balance                                                                          isOwner
----------------  -------------------------------------------------------------------------------  -------
.?˟???(?4[W?      0000000000000000000000000000000000000000000000000000000140000000000000000000000  0      
y?D???ꎇ ?[?>      0000000000000000000000000000000000000000000000000000000290000000000000000000000  0      
3?ek{3F4oi}??B?   0000000000000000000000000000000000000000000000000000000230000000000000000000000  0      
```

</Steps>

### Column types

These are the [SQLite data types](https://www.sqlite.org/datatype3.html) used by each `ponder.schema.ts` column type.

| Schema column type | SQLite column type  | Notes                                                                       |
| :----------------- | :------------------ | :-------------------------------------------------------------------------- |
| `p.string(){:ts}`  | `TEXT`              |                                                                             |
| `p.hex(){:ts}`     | `BLOB{:sql}`        |                                                                             |
| `p.int(){:ts}`     | `INTEGER{:sql}`     |                                                                             |
| `p.bigint(){:ts}`  | `VARCHAR(79){:sql}` | Supports EVM `uint256{:solidity}` and `int256{:solidity}` (custom encoding) |
| `p.float(){:ts}`   | `REAL`              |                                                                             |
| `p.boolean(){:ts}` | `INTEGER{:sql}`     | `0` is `false{:ts}`, `1` is `true{:ts}`                                     |
| `p.json(){:ts}`    | `JSONB{:sql}`       |                                                                             |


#### SQLite bigint encoding

SQLite does not natively support integers larger than 8 bytes. To safely store and compare large integers (such as 32-byte EVM `uint256{:solidity}` values) in SQLite, we designed an encoding that uses `VARCHAR(79){:sql}` and takes advantage of SQLite's native lexicographic sort. [Here is the reference implementation](https://github.com/ponder-sh/ponder/blob/main/packages/core/src/utils/encoding.ts) used by Ponder internally.

### Indexes

To create indexes on specific columns, use the `p.index()` function in `ponder.schema.ts` Do not manually construct database indexes. [Read more](/docs/schema#indexes).

## Postgres

### Database schema

Ponder uses the **public** database schema by default. To use a different schema, use the `onchainSchema` function `ponder.schema.ts`.

```ts filename="ponder.schema.ts" {3}
import { onchainSchema } from "@ponder/core"

export const schema = onchainSchema("ponder");

export const account = schema.table("account", (p) => ({
  address: p.evmHex().primaryKey(),
  balance: p.evmBigint().notNull(),
}));
```

Like with SQLite, Ponder also uses the `ponder_sync` Postgres database schema for cached RPC data.

### Connect using `psql`

To get oriented, connect to the database using `psql` ([installation guide](https://www.timescale.com/blog/how-to-install-psql-on-mac-ubuntu-debian-windows/)) and run a few test queries. For the queries that follow, assume there is a Ponder app running with this `ponder.schema.ts`.

<details>
  <summary><p>Example `ponder.schema.ts`</p></summary>
  <p />

  ```ts filename="ponder.schema.ts"
  import { onchainTable } from "@ponder/core";

  export const account = onchainTable("account", (p) => ({
    address: p.evmHex().primaryKey(),
    balance: p.evmBigint().notNull(),
  }));

  export const transferEvent = onchainTable("transfer_event", (p) => ({
    id: p.serial().primaryKey(),
    from: p.evmHex().notNull(),
    to: p.evmHex().notNull(),
    amount: p.evmBigint().notNull(),
    timestamp: p.integer().notNull(),
  }))
  ```
</details>

<Steps>

#### Connection string

Connect using the same connection string that your Ponder app uses (the `DATABASE_URL` environment variable).

```bash filename="shell"
psql 'postgresql://username:password@localhost:5432/your_database'
```

#### Display tables

Use the `\dt` command to list all tables in the `public` schema.

```bash filename="psql"
\dt
```

```plaintext filename="psql (result)"
username=# \dt
              List of relations
 Schema | Name                | Type  | Owner    
--------+---------------------+-------+----------
 public | ****__account       | table | username
 public | ****__transfer_event | table | username
(4 rows)
```

All user tables are prefixed by an unique, four character instance ID. [Read more](/docs/production/deploy#table-names-and-live-views)

If you're using a schema other than `public`, you'll need to include a pattern:

```bash filename="psql"
\dt another_schema.*
```

#### Display views

Use the `\dv` command to list all views in the `public` schema.

```bash filename="psql"
\dv
```

```plaintext filename="psql (result)"
username=# \dv
            List of relations
 Schema | Name           | Type  | Owner    
--------+----------------+-------+----------
 public | account        | view | username
 public | transfer_event | view | username
(4 rows)
```

#### Select rows

Select a few `account` rows.

```sql filename="psql"
SELECT * FROM "account" LIMIT 5;
```

```plaintext filename="psql (result)"
username=# SELECT * FROM "account" LIMIT 5;
                  address                   |         balance         | 
--------------------------------------------+-------------------------+
 0xf73fe15cfb88ea3c7f301f16ade3c02564aca407 | 10000000000000000000000 |
 0xb0659bc97ed61b37d6b140f3e12a41d471781714 | 20000000000000000000000 |
 0x52932f5b2767d917c3134140168f2176c94e8b2c | 10000000000000000000000 |
 0xfb7ca75b3ce099120602b5ab7104cff030ee43f8 |                       0 |
 0x9ccc6c5a9d25429f55ad9af6363c1c4f16b179ad |  7000000000000000000000 |
(5 rows)
```

#### Aggregate data

Find the total number of transfers sent to each account.

```sql filename="psql"
SELECT "to", COUNT(*) AS transfer_count
  FROM "transfer_event"
  GROUP BY "to"
  ORDER BY transfer_count DESC
  LIMIT 5;
```

```plaintext filename="psql (result)"
username=# SELECT "to", COUNT(*) AS transfer_count FROM "transfer_event" GROUP BY "to" ORDER BY transfer_count DESC LIMIT 5;
                     to                     | transfer_count 
--------------------------------------------+----------------
 0x5d752f322befb038991579972e912b02f61a3dda |           2342
 0x1337f7970e8399ccbc625647fce58a9dada5aa66 |            313
 0x9726041047644626468922598128349778349982 |            306
 0x27239549dd40e1d60f5b80b0c4196923745b1fd2 |            256
 0x450638daf0caedbdd9f8cb4a41fa1b24788b123e |            238
(5 rows)
```

</Steps>

### Column types

| Schema column type | Postgres column type          | Notes                                                     |
| :----------------- | :---------------------------- | :-------------------------------------------------------- |
| `evmHex(){:ts}`    | `TEXT`                        | Values are lowercased and padded to be byte aligned       |
| `evmBigint(){:ts}` | `NUMERIC(78, 0){:sql}`        | Supports EVM `uint256{:solidity}` and `int256{:solidity}` |
