---
description: "An introduction to Ponder"
title: "Introduction"
---

import { Callout } from "nextra-theme-docs";

# Ponder

Ponder is an open-source framework for blockchain application backends.

<Callout type="warning">
  Today, the _only_ supported use case for Ponder is building a GraphQL API from
  blockchain event logs. Over time, Ponder aims to solve for more use cases,
  stateful side effects, building non-GraphQL APIs, and integrating with
  third-party services like Discord, Slack, and Sendgrid.
</Callout>

## Architecture overview

<Callout type="info">
  Ponder's architecture is very similar to Graph Protocol subgraphs. If you're
  familiar with building subgraphs, you can skip to [Getting
  started](/getting-started).
</Callout>

**_TODO_** Figure 1: Blockchain events → Event handler functions → Entity database → GraphQL API → Client app

## Example: ENS

Let's use Ponder to build a GraphQL API that tracks ownership of Ethereum Name Service registrations.

The ENS `BaseRegistrar` contract emits a `NameRegistered` event every time a user registers a new ENS name. Here's the relevant snippet from that contract:

```solidity
contract BaseRegistrar {
  event NameRegistered(string name, address owner);

  function registerName(string calldata name, address owner) external {
    // ...

    emit NameRegistered(name, owner);
  }
}
```

<div className="steps-container">

### Ponder config

Now, let's add `BaseRegistrar` as a Source in our Ponder config file. Ponder's indexing engine will now fetch all the `NameRegistered` events that have been emitted by the contract.

```ts filename="ponder.config.js"
export default {
  networks: [
    {
      name: "mainnet",
      chainId: 1,
      rpcUrl: "https://eth-mainnet.g.alchemy.com/v2/..."
    }
  ],
  sources: [
    {
      name: "BaseRegistrar",
      network: "mainnet",
      abi: "./abis/BaseRegistrar.json",
      address: "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85",
      startBlock: 9380410
    }
  ]
};
```

### Entity schema

The `schema.graphql` file defines the entity objects that our GraphQL API will serve. Here, we have an `EnsName` entity that stores the ENS name, the owner address, and a timestamp.

```graphql filename="schema.graphql"
type EnsName @entity {
  id: ID!
  name: String!
  owner: String!
  registeredAt: Int!
}
```

### Event handler functions

Event handlers are JavaScript functions that accept a contract event and insert data into the entity store.

Here's an event handler to process the `NameRegistered` event. It inserts an `EnsName` entity into the store using the event parameters and the block timestamp.

{/* prettier-ignore */}
```ts filename="EthereumNameService.ts"
async function handleNameRegistered(event, context) {
  const { EnsName } = context.entities

  await EnsName.insert(`${owner}-${name}`, {
    name: event.params.name,
    owner: event.params.owner,
    registeredAt: event.block.timestamp,
  })
}
```

### GraphQL API

Now that we've inserted some data into the entity store, we can query that data from the autogenerated GraphQL API.

**_TODO_** Figure 2: GraphiQL interface or figure with query and data

</div>

## Get started

[Migrate a Graph Protocol subgraph →](/getting-started/migrate-subgraph)

[Create a new Ponder project →](/getting-started/new-project)
